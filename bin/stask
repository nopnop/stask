#! /usr/bin/env node
'use strict'
const minimist = require('minimist')
const pkg = require('../package.json')
const util = require('util')
const path = require('path')
const Stream = require('stream')
const through2 = require('through2')
const stringify = require('json-stable-stringify')
const ndjson = require('ndjson')

// List of available actions
const actions = {
  parse: require('../lib/parse'),
  read: require('../lib/read'),
  format: require('../lib/format'),
  watch: require('../lib/watch')
}

// Read command line options
const argv = minimist(process.argv.slice(2), {
  boolean: true,
  string: ['cwd'],
  alias: {
    h: 'help',
    w: 'watch',
    V: 'version'
  },
  default: {
    watch: false,
    cwd: process.cwd()
  }
})

/**
 * Print command usages
 */
function printHelp () {
  let helpActions = Object.keys(actions).map((key) => {
    let help = (actions[key].help || 'Undocumented').split('\n')[0].trim()
    return `    - ${key}: ${help}`
  })

  console.log(`
  Usage: stask [options] <action> [...]

  Options:
    -h, --help       Output command usages
    -V, --version    Output the version

  Actions:
${helpActions.join('\n')}

`)
}

/**
 * Handle error and print out to user
 * @param  {Error} error Error instance
 */
function handleError (error) {
  console.error('Error:', error.stack)
  process.exit(typeof error.code === 'number' ? error.code : 1)
}

/**
 * Handler stask action
 * @param  {string} action   Action to perform
 * @param  {object} options  Action options
 * @return {Promise}
 */
function handleAction (options) {
  let action = options.action

  if (!action || !actions[action]) {
    console.error('Error: Unknown action (%s)', action)
    printHelp()
    process.exit(1)
  }

  let result
  switch (action) {
    case 'format':
      process.stdin
        .pipe(ndjson.parse())
        .pipe(actions.format(options))
        .pipe(process.stdout)
      break
    // case 'watch':
    //   actions.watch(options)
    //   break
    default:
      result = actions[action](options.files[0], options)
      break
  }

  function handleStream (stream) {
    stream.on('error', handleError)
    stream.pipe(through2.obj((chunk, encoding, next) => {
      if (typeof chunk === 'object') {
        next(null, stringify(chunk) + '\n')
      } else {
        next(null, chunk)
      }
    })).pipe(process.stdout)
  }

  function handlePromise (promise) {
    return result.then((result) => {
      if (result instanceof Stream) {
        return handleStream(result)
      } else {
        console.log(util.inspect(result, { colors: true }))
      }
    })
  }

  if (!result) {
    return
  } else if (result instanceof Stream) {
    return handleStream(result)
  } else if (result.then) {
    return handlePromise(result)
  }
}

// ---------------

// Extract action
const options = Object.assign({}, argv, {
  action: argv._[0],
  files: argv._.slice(1),
  cwd: path.resolve(argv.cwd)
})

// Help
if (argv.help) {
  printHelp()
  process.exit(0)
}

// Version
if (argv.version) {
  console.log(pkg.version)
  process.exit(0)
}

// Actions
Promise.resolve(handleAction(options))
  .catch((error) => {
    handleError(error)
  })
